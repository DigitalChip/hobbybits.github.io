---
draft: false
title: '2. Location: Мастер маршрутизации запросов'
description: "Location: Мастер маршрутизации запросов в Nginx. От статики до проксирования"
author: 'DigitalChip'
tags: ["nginx","https","proxy"]
categories: ["nginx","devops"]
---

# Location: Мастер маршрутизации запросов в Nginx. От статики до проксирования

## Сердце виртуального хоста

В [предыдущей статье](/nginx/nginx1) мы разобрали иерархию: как Nginx выбирает нужный виртуальный хост (server) на основе порта и имени. Но что происходит после? Как решить, отдать ли статический файл, передать запрос приложению на Python или Nodejs, или вернуть редирект?

За это отвечает контекст `location`. Это самый важный и гибкий инструмент внутри блока `server`. Фактически, `location` — это набор правил обработки для конкретных путей (URI) вашего сайта. Понимание его работы — ключ к тонкой настройке поведения любого веб-проекта.

## 1. Анатомия директивы location. Модификаторы и приоритеты

Синтаксис блока выглядит так: `location [модификатор] URI-шаблон { ... }`.

Модификатор определяет, как будет сравниваться URI запроса с шаблоном. От него кардинально зависит логика выбора.

`location = /точный/путь` (Точное совпадение)

Срабатывает только при полном, byte-to-byte совпадении URI.

Приоритет: наивысший. Если запрос ему соответствует, этот блок будет выбран мгновенно, без дальнейших проверок других location.

Идеально для: часто запрашиваемых конкретных страниц (главная, robots.txt, favicon.ico), где нужно минимизировать накладные расходы.

```nginx
location = / {
    root /var/www/site;
    index index.html;
}
```

`location ^~ /префикс/` (Приоритетное префиксное совпадение)

Срабатывает для всех URI, начинающихся с указанной строки.

Приоритет: очень высокий. Если запрос совпадает с таким `location`, имеющим самый длинный из совпадающих префиксов, Nginx прекращает поиск по регулярным выражениям и использует его.

Идеально для: служебных путей, где важна скорость (`/admin/`, `/api/`) и нужно избежать проверки regexp.

`location ~ паттерн` (Регулярное выражение, регистрозависимое)
`location ~* паттерн` (Регулярное выражение, регистронезависимое)

Срабатывает, если URI соответствует указанному регулярному выражению Perl-совместимого синтаксиса (PCRE).

Приоритет: средний. Проверяются последовательно, в порядке объявления в конфигурации. Первое совпадение — побеждает.

Идеально для: сложных правил, например, обработка всех графических файлов или скриптов определенных расширений.

```nginx
location ~ \.(jpg|jpeg|png|gif|ico)$ {
    root /var/www/media;
    expires 1y;
    add_header Cache-Control "public, immutable";
}

location ~* \.(php|php5|phtml)$ {
    deny all; # Запрет доступа к исходникам PHP
}
```


`location /префикс/` (Обычное префиксное совпадение, БЕЗ модификатора)

Срабатывает для всех URI, начинающихся с указанной строки.

Приоритет: низший среди префиксных. Используется по умолчанию, если не сработали более приоритетные правила (=, ^~) и ни одно регулярное выражение.

Идеально для: базовых правил для разделов сайта (/blog/, /catalog/).

Важно: Модификаторы = и ^~ имеют более высокий приоритет, чем регулярные выражения. Это позволяет защитить критические или высоконагруженные пути от более медленной проверки regexp.

## 2. Алгоритм выбора location: пошаговый разбор

Когда Nginx получает запрос и определил нужный блок server, он действует так:

Проверяет все location с модификатором =. При точном совпадении — выбор завершен.

Находит самый длинный совпадающий префиксный location (с ^~ или без модификатора). Запоминает его.

Проверяет location с регулярными выражениями (~ и ~*) в том порядке, в котором они указаны в конфигурационном файле.

Если найдено совпадающее регулярное выражение — выбор падает на него, и поиск прекращается.

Если совпадений с regexp нет — используется тот самый длинный префиксный location, который был найден на шаге 2.

Специальный случай: Если самый длинный префиксный location имеет модификатор ^~ — шаг 3 (проверка regexp) пропускается, и используется сразу этот префиксный блок.

Простая мнемоника: Сначала =, потом самый длинный префикс, потом regexp по порядку, но ^~ может "перепрыгнуть" проверку regexp.

## 3. Практика: Директивы для работы с контентом

Внутри location вы определяете, что делать с запросом. Вот ключевые директивы:

`root` — задает базовый каталог для поиска файлов. Итоговый путь к файлу формируется как `root` + `URI`.

```nginx
location /static/ {
    root /var/www/site; # Для запроса /static/logo.png Nginx будет искать /var/www/site/static/logo.png
}
```

`alias` — задает путь-замену для указанного `location`. URI, соответствующий части `location`, заменяется на значение `alias`.

```nginx
location /uploads/ {
    alias /var/data/media/; # Для запроса /uploads/photo.jpg Nginx будет искать /var/data/media/photo.jpg
    # Обратите внимание на слэш! Его наличие важно для согласованности путей.
}
```

Ключевое отличие: `root` добавляет `URI` к пути, `alias` заменяет часть `URI`, совпавшую с `location`, на указанный путь.

`try_files` — мощная директива для создания цепочки проверок.

По очереди проверяет существование файлов или директорий по заданным путям.

Последний параметр может быть именем location (с префиксом `=`), на который произойдет внутреннее перенаправление, или кодом ошибки.

```nginx
location / {
    # Сначала попробовать отдать файл по точному URI, потом директорию /index.html, если ничего не найдено - отдать на обработку бэкенду.
    try_files $uri $uri/ /index.php?$query_string;
}

location /assets/ {
    # Попробовать отдать файл, если его нет - вернуть 404.
    try_files $uri =404;
}
```

`proxy_pass` — директива для проксирования (передачи) запроса другому серверу (бэкенду).

```nginx
location /api/ {
    # Передает запрос приложению, работающему на localhost:3000
    proxy_pass http://127.0.0.1:3000;
    proxy_set_header Host $host; # Важно: передавать оригинальный заголовок Host
    proxy_set_header X-Real-IP $remote_addr; # Передавать реальный IP клиента
}
```

## 4. Собираем всё вместе: Пример сложной конфигурации

Рассмотрим server для условного сайта с админкой, API и статикой.

```nginx
server {
    listen 80;
    server_name mysite.com;

    # 1. Точное совпадение - главная страница (максимальная скорость)
    location = / {
        root /var/www/mysite;
        index index.html;
    }

    # 2. Приоритетный префикс для админки (защищаем от случайного regexp)
    location ^~ /admin/ {
        # Проверка аутентификации может быть здесь
        proxy_pass http://localhost:8000;
    }

    # 3. Регулярное выражение для всех картинок и стилей
    location ~* \.(css|js|jpg|png|svg)$ {
        root /var/www/mysite/static;
        expires 30d; # Кэширование в браузере на 30 дней
        add_header Cache-Control "public, immutable";
    }

    # 4. Префикс для API
    location /api/ {
        proxy_pass http://localhost:3000/; # Обратите внимание на слэш в конце!
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # 5. Общий fallback-блок для всех остальных запросов (например, для SPA)
    location / {
        root /var/www/mysite;
        try_files $uri $uri/ /index.html;
    }
}
```

Разбор логики для запроса `GET /api/v1/user`:

Пропускается `= /` (нет точного совпадения).

Проверяется `^~ /admin/` (не совпадает).

Проверяются regexp `~* \.(css|js|jpg|png|svg)$` (не совпадает).

Находится префиксный `location /api/` (совпадает!). Это самый длинный совпадающий префикс.

Дальнейшая проверка regexp не происходит, потому что есть совпадающий префикс, но у него нет модификатора `^~`. Однако regexp уже проверены на шаге 3 и не сработали.

Запрос передается (`proxy_pass`) бэкенду на `localhost:3000`, при этом URI `/v1/user` будет добавлен к указанному адресу (так как в `proxy_pass` есть завершающий слэш).

## Заключение и следующий шаг

Контекст `location` — это инструмент декларативной маршрутизации. Вы не пишете процедурный код, а описываете условия (`=`, `^~`, `~`, `префикс`) и соответствующие им действия (`root`, `proxy_pass`, `try_files`). Понимание приоритетов и тонкостей директив позволяет строить чистые, эффективные и предсказуемые конфигурации.

В следующей статье мы выведем взаимодействие с бэкендами на новый уровень, подробно разобрав директиву `proxy_pass` и весь спектр сопутствующих настроек: от правильной передачи заголовков, управления таймаутами и буферизацией до балансировки нагрузки между несколькими серверами приложений. Это основа для работы с современными микросервисными архитектурами.