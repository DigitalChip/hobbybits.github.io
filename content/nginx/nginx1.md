---
draft: false
title: '1. Nginx - Анатомия конфигурации Nginx'
description: "Анатомия конфигурации Nginx: от структуры к логике принятия решений"
author: 'DigitalChip'
tags: ["nginx","https","proxy"]
categories: ["nginx","devops"]
---

# Анатомия конфигурации Nginx: от структуры к логике принятия решений

##  Конфигурация как система правил

Nginx — высокопроизводительный веб-сервер и обратный прокси. Его мощь и гибкость проявляются не через графический интерфейс, а через текстовые конфигурационные файлы. Чтобы эффективно им управлять, необходимо понимать не просто синтаксис, а принципы, по которым Nginx интерпретирует эти файлы. Поэтому, давайте разберем базовые элементы конфигурации, их иерархию и логику, по которой Nginx выбирает, как обработать входящий запрос.

## 1. Базовые элементы: Директивы и контексты

Конфигурация Nginx построена на двух основных понятиях: директивы и контексты.

**Директива** — это конкретная инструкция. Она имеет имя и параметры и завершается точкой с запятой (;).

`worker_processes auto;` — директива `worker_processes` с параметром `auto`.

`error_log /var/log/nginx/error.log warn;` — директива `error_log` с двумя параметрами.

**Контекст** — это блок, ограниченный фигурными скобками `{` и `}`, который группирует директивы и определяет область их действия. Контексты могут быть вложенными.

`http { ... }` — контекст уровня HTTP.

`server { ... }` — контекст виртуального хоста, вложенный в http.

`location /api { ... }` — контекст для определенного URI, вложенный в `server`.

Ключевой принцип: Директивы, объявленные в вышележащем (родительском) контексте, обычно наследуются вложенными контекстами, если они явно не переопределены. Это формирует древовидную структуру конфигурации.

## 2. Иерархия контекстов: от общего к частному

Рассмотрим основные контексты в порядке их вложенности и ответственности.

### Главный контекст (Main Context)

Это корневой уровень основного файла конфигурации (обычно `nginx.conf`).

Здесь задаются глобальные параметры, влияющие на работу Nginx в целом: пользователь и группа (user), количество рабочих процессов (worker_processes), настройка обработки событий ОС (events), расположение файла с PID и так далее.

Сюда же подключаются другие конфигурационные файлы с помощью директивы `include`.

### Контекст http

Объявляется директивой `http { ... }` внутри главного контекста.

Всё, что связано с обработкой HTTP- и HTTPS-трафика, описывается здесь.

Здесь задаются настройки по умолчанию для всех нижележащих виртуальных серверов: MIME-типы (`include mime.types;`), логи доступа (`access_log`), таймауты, настройки сжатия (`gzip`), подключение внешних файлов конфигураций (например, `include /etc/nginx/conf.d/*.conf;`).

Внутри `http` определяются один или несколько контекстов `server`.

### Контекст server

Это определение виртуального хоста (Virtual Host). Он позволяет Nginx обслуживать множество независимых сайтов (доменов) на одном IP-адресе.

Выбор конкретного контекста server для обработки входящего запроса определяется двумя ключевыми директивами внутри него:

`listen` — определяет IP-адрес и порт, которые сервер будет слушать (например, `listen 80;`, `listen 443 ssl;`, `listen 10.0.0.1:8080;`).

`server_name` — сопоставляет доменное имя из заголовка `Host` HTTP-запроса. Может содержать точные имена (`example.com`), wildcard-маски (`*.example.com`), или даже регулярные выражения (с префиксом `~`).

#### Алгоритм выбора server-блока:

Nginx ищет все блоки `server`, чья директива `listen` соответствует IP и порту запроса.

Среди них он ищет блок с точным совпадением `server_name` с заголовком `Host`.

Если точного совпадения нет, ищет блок с wildcard-именем, соответствующим запросу (например, `*.example.com`).

Если и его нет, выбирает блок, соответствующий регулярному выражению (если есть).

Если ничего не найдено, используется блок server по умолчанию для данного порта: это либо блок с директивой `listen ... default_server;`, либо первый блок `server`, объявленный для этого порта.

Внутри `server` определяются контексты `location`.

### Контекст location

Это самый важный инструмент для маршрутизации запросов внутри виртуального хоста.

Он определяет, как обрабатывать запросы к определенным URI (путям).

Синтаксис: `location [модификатор] URI-шаблон { ... }`.

Модификаторы определяют тип сопоставления:

(без модификатора) или `=` — Префиксное совпадение. `location /api/` соответствует `/api/`, `/api/users`, `/api/v1/`. `location = /api/` — только точное совпадение с `/api/`.

`~` и `~*` — Совпадение по регулярному выражению (регистрозависимое и регистронезависимое соответственно). `location ~ \.(jpg|png|gif)$`.

`^~` — Префиксное совпадение с наивысшим приоритетом среди префиксных. Отменяет проверку регулярных выражений для данного совпадения.

#### Алгоритм выбора location блока (упрощенно):

Nginx сканирует все префиксные (без регулярных выражений) location.

Запоминает самый длинный совпадающий префикс.

Затем проверяет location с регулярными выражениями в порядке их объявления в конфигурации.

При первом совпадении с регулярным выражением — этот location используется, и поиск прекращается.

Если совпадений с регулярными выражениями не было, используется самый длинный префиксный location.

Модификаторы `=` и `^~` меняют этот алгоритм, давая соответствующим блокам наивысший приоритет.

## 3. Практический пример: Два сайта на одном сервере

Рассмотрим фрагмент конфигурации внутри блока `http`:

```nginx
# Виртуальный хост для сайта example.com
server {
    listen 80;
    server_name example.com www.example.com;

    location / {
        root /var/www/example.com/html;
        index index.html;
    }

    location /static/ {
        alias /var/www/example.com/static/;
        expires 30d;
    }
}

# Виртуальный хост для блога blog.example.com
server {
    listen 80;
    server_name blog.example.com;

    location / {
        proxy_pass http://127.0.0.1:8080; # Передача запроса бэкенду
        proxy_set_header Host $host;
    }
}

# Сервер по умолчанию для порта 80 - обработает запросы с неизвестным Host или без него
server {
    listen 80 default_server;
    server_name _; # Специальное значение, явно указывающее на "любое другое имя"
    return 444; # Закрывает соединение без ответа (Nginx-specific код)
}
```

### Как это работает

1. Запрос `GET /static/logo.png HTTP/1.1` с заголовком `Host: example.com` приходит на порт `80`.

2. Nginx находит все блоки server с `listen 80`.

3. Сравнивает `Host: example.com` с `server_name` в найденных блоках. Выбирает первый блок, где есть точное совпадение (`example.com`).

4. Внутри выбранного блока `server` ищет подходящий `location`. Путь `/static/logo.png` совпадает с префиксным шаблоном `/static/`. Самый длинный префикс — `/static/`.

5. Проверяет `location` с регулярными выражениями. В данном примере их нет.

6. Применяет правила из `location /static/`: использует `alias` для отдачи файла `/var/www/example.com/static/logo.png` и устанавливает заголовок `Cache-Control` на 30 дней.

## Заключение и следующий шаг

Понимание иерархии контекстов (main -> http -> server -> location) и алгоритмов выбора нужного блока — это 80% успеха в управлении Nginx. В следующей статье мы детально разберем контекст `location` — основной инструмент для определения логики обработки запросов. Мы рассмотрим разницу между `root` и `alias`, изучим директивы для работы с индексными файлами, переопределения ошибок и, что наиболее важно, принципы проксирования запросов к бэкенд-приложениям с помощью `proxy_pass`.
